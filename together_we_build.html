<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Together We Build - Mark Walhimer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Georgia', serif;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            font-size: 28px;
            opacity: 0;
            transition: opacity 1.5s;
            pointer-events: none;
            max-width: 80%;
            line-height: 1.8;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #message.show {
            opacity: 1;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 350px;
            line-height: 1.6;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        #info h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #00ffaa;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.8);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: right;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        .stat-number {
            font-size: 24px;
            color: #00ffaa;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="message"></div>
    <div id="info">
        <h3>TOGETHER WE BUILD</h3>
        <div><strong>How to participate:</strong></div>
        <div style="margin-top:8px;">
            • <strong>Click alone:</strong> Create a point of light<br>
            • <strong>2 clicks close together:</strong> Form a line<br>
            • <strong>3+ clicks:</strong> Create triangles, shapes<br>
            • <strong>More cooperation:</strong> Build complex structures
        </div>
        <div style="margin-top:10px; font-style:italic; color: #00ffaa;">
            Try clicking with friends across the screen
        </div>
    </div>
    <div id="stats">
        <div>Contributions: <span class="stat-number" id="contributions">0</span></div>
        <div>Shapes Formed: <span class="stat-number" id="shapes">0</span></div>
        <div>Current Cooperators: <span class="stat-number" id="cooperators">0</span></div>
    </div>
    <script>
        // TOGETHER WE BUILD - Cooperative Community Art
        // Mark Walhimer 2026
        
        let points = [];
        let shapes = [];
        let recentClicks = [];
        let totalContributions = 0;
        let totalShapes = 0;
        let messageTimer = 0;
        let currentCooperators = 0;
        
        const CLICK_WINDOW = 2000; // 2 seconds to be considered "together"
        const CONNECTION_DISTANCE = 250; // pixels
        
        const messages = [
            "Two voices create dialogue",
            "Three perspectives form understanding",
            "Many hands build community",
            "Together we create what alone we cannot",
            "Culture emerges from collaboration"
        ];
        
        let messagePhase = 0;
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            strokeCap(ROUND);
            strokeJoin(ROUND);
        }
        
        function draw() {
            background(0, 0, 3);
            
            messageTimer++;
            
            // Clean up old clicks from recentClicks
            let now = millis();
            recentClicks = recentClicks.filter(c => now - c.time < CLICK_WINDOW);
            currentCooperators = recentClicks.length;
            
            // Draw existing shapes (they persist)
            for (let shape of shapes) {
                shape.age++;
                
                // Shapes slowly fade and grow
                let fadeProgress = min(shape.age / 120, 1);
                let growProgress = min(shape.age / 60, 1);
                
                if (shape.type === 'line') {
                    strokeWeight(map(growProgress, 0, 1, 2, 4));
                    stroke(shape.hue, 70, 90, map(fadeProgress, 0, 1, 80, 30));
                    line(shape.p1.x, shape.p1.y, shape.p2.x, shape.p2.y);
                    
                } else if (shape.type === 'triangle') {
                    noStroke();
                    fill(shape.hue, 60, 80, map(fadeProgress, 0, 1, 40, 15));
                    triangle(shape.p1.x, shape.p1.y, shape.p2.x, shape.p2.y, shape.p3.x, shape.p3.y);
                    
                    // Draw edges
                    strokeWeight(2);
                    stroke(shape.hue, 70, 90, map(fadeProgress, 0, 1, 70, 25));
                    line(shape.p1.x, shape.p1.y, shape.p2.x, shape.p2.y);
                    line(shape.p2.x, shape.p2.y, shape.p3.x, shape.p3.y);
                    line(shape.p3.x, shape.p3.y, shape.p1.x, shape.p1.y);
                    
                } else if (shape.type === 'polygon') {
                    // Complex shapes from 4+ points
                    noStroke();
                    fill(shape.hue, 50, 85, map(fadeProgress, 0, 1, 35, 12));
                    beginShape();
                    for (let p of shape.points) {
                        vertex(p.x, p.y);
                    }
                    endShape(CLOSE);
                    
                    // Draw edges
                    strokeWeight(2);
                    stroke(shape.hue, 70, 90, map(fadeProgress, 0, 1, 60, 20));
                    for (let i = 0; i < shape.points.length; i++) {
                        let p1 = shape.points[i];
                        let p2 = shape.points[(i + 1) % shape.points.length];
                        line(p1.x, p1.y, p2.x, p2.y);
                    }
                }
            }
            
            // Draw individual points with glow
            for (let point of points) {
                point.age++;
                
                let pulse = sin(point.age * 0.05 + point.offset) * 0.5 + 0.5;
                let alpha = map(point.age, 0, 300, 80, 20);
                
                // Glow
                let glowSize = 30 + pulse * 10;
                for (let r = glowSize; r > 0; r -= glowSize/4) {
                    let glowAlpha = map(r, 0, glowSize, alpha * 0.6, 0);
                    fill(point.hue, 70, 90, glowAlpha);
                    noStroke();
                    ellipse(point.x, point.y, r * 2);
                }
                
                // Core
                fill(point.hue, 80, 100, alpha);
                ellipse(point.x, point.y, 8 + pulse * 3);
            }
            
            // Draw lines between recent clicks (forming connections)
            stroke(180, 50, 90, 30);
            strokeWeight(1);
            for (let i = 0; i < recentClicks.length; i++) {
                for (let j = i + 1; j < recentClicks.length; j++) {
                    let d = dist(recentClicks[i].x, recentClicks[i].y, 
                                recentClicks[j].x, recentClicks[j].y);
                    if (d < CONNECTION_DISTANCE) {
                        let alpha = map(d, 0, CONNECTION_DISTANCE, 50, 5);
                        stroke(180, 50, 90, alpha);
                        line(recentClicks[i].x, recentClicks[i].y, 
                             recentClicks[j].x, recentClicks[j].y);
                    }
                }
            }
            
            // Update stats
            document.getElementById('contributions').textContent = totalContributions;
            document.getElementById('shapes').textContent = totalShapes;
            document.getElementById('cooperators').textContent = currentCooperators;
        }
        
        function mousePressed() {
            let now = millis();
            
            // Add to points
            let newPoint = {
                x: mouseX,
                y: mouseY,
                time: now,
                hue: (mouseX / width * 180 + mouseY / height * 180) % 360,
                age: 0,
                offset: random(TWO_PI)
            };
            
            points.push(newPoint);
            recentClicks.push(newPoint);
            totalContributions++;
            
            // Check for nearby recent clicks to form shapes
            let nearby = recentClicks.filter(c => {
                let d = dist(mouseX, mouseY, c.x, c.y);
                return d < CONNECTION_DISTANCE && d > 5; // Not self
            });
            
            if (nearby.length >= 1) {
                // Sort by distance
                nearby.sort((a, b) => {
                    let da = dist(mouseX, mouseY, a.x, a.y);
                    let db = dist(mouseX, mouseY, b.x, b.y);
                    return da - db;
                });
                
                // Determine what shape to create based on number of cooperators
                if (nearby.length === 1) {
                    // 2 people = line
                    createLine(newPoint, nearby[0]);
                    showMessage("Two voices create dialogue");
                    
                } else if (nearby.length === 2) {
                    // 3 people = triangle
                    createTriangle(newPoint, nearby[0], nearby[1]);
                    showMessage("Three perspectives form understanding");
                    
                } else if (nearby.length >= 3) {
                    // 4+ people = polygon
                    createPolygon(newPoint, nearby.slice(0, min(nearby.length, 6)));
                    showMessage("Together we create what alone we cannot");
                }
            }
        }
        
        function createLine(p1, p2) {
            let avgHue = (p1.hue + p2.hue) / 2;
            shapes.push({
                type: 'line',
                p1: {x: p1.x, y: p1.y},
                p2: {x: p2.x, y: p2.y},
                hue: avgHue,
                age: 0
            });
            totalShapes++;
        }
        
        function createTriangle(p1, p2, p3) {
            let avgHue = (p1.hue + p2.hue + p3.hue) / 3;
            shapes.push({
                type: 'triangle',
                p1: {x: p1.x, y: p1.y},
                p2: {x: p2.x, y: p2.y},
                p3: {x: p3.x, y: p3.y},
                hue: avgHue,
                age: 0
            });
            totalShapes++;
        }
        
        function createPolygon(center, others) {
            let allPoints = [center, ...others];
            
            // Sort points by angle from centroid for proper polygon
            let cx = allPoints.reduce((sum, p) => sum + p.x, 0) / allPoints.length;
            let cy = allPoints.reduce((sum, p) => sum + p.y, 0) / allPoints.length;
            
            allPoints.sort((a, b) => {
                return atan2(a.y - cy, a.x - cx) - atan2(b.y - cy, b.x - cx);
            });
            
            let avgHue = allPoints.reduce((sum, p) => sum + p.hue, 0) / allPoints.length;
            
            shapes.push({
                type: 'polygon',
                points: allPoints.map(p => ({x: p.x, y: p.y})),
                hue: avgHue,
                age: 0
            });
            totalShapes++;
        }
        
        function showMessage(text) {
            let msgElement = document.getElementById('message');
            msgElement.textContent = text;
            msgElement.classList.add('show');
            
            setTimeout(() => {
                msgElement.classList.remove('show');
            }, 3000);
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
        
        // Encourage periodic messages
        setInterval(() => {
            if (totalShapes > 0 && totalShapes % 5 === 0 && messageTimer > 600) {
                showMessage(random(messages));
                messageTimer = 0;
            }
        }, 5000);
    </script>
</body>
</html>
